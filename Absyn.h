/* File generated by the BNF Converter (bnfc 2.9.5). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;

/********************   Forward Declarations    ***********************/
struct S_;
typedef struct S_ *S;

struct Block_;
typedef struct Block_ *Block;

struct CMDS_;
typedef struct CMDS_ *CMDS;

struct CMD_;
typedef struct CMD_ *CMD;

struct ATRIB_;
typedef struct ATRIB_ *ATRIB;

struct EXP_;
typedef struct EXP_ *EXP;

struct UAI_;
typedef struct UAI_ *UAI;

struct OPerL_;
typedef struct OPerL_ *OPerL;

struct OPerA_;
typedef struct OPerA_ *OPerA;

struct OPL_;
typedef struct OPL_ *OPL;

struct ZOIA_;
typedef struct ZOIA_ *ZOIA;

struct VEMCA_;
typedef struct VEMCA_ *VEMCA;

struct QUANTO_;
typedef struct QUANTO_ *QUANTO;

struct PA_;
typedef struct PA_ *PA;

struct VALUE_;
typedef struct VALUE_ *VALUE;

struct Type_;
typedef struct Type_ *Type;

struct TREM_;
typedef struct TREM_ *TREM;

struct STRUCT_;
typedef struct STRUCT_ *STRUCT;

struct HeteroElements_;
typedef struct HeteroElements_ *HeteroElements;

struct HeteroElement_;
typedef struct HeteroElement_ *HeteroElement;

struct FUNC_;
typedef struct FUNC_ *FUNC;

struct VAILA_;
typedef struct VAILA_ *VAILA;

struct LABEL_;
typedef struct LABEL_ *LABEL;

struct ConjValues_;
typedef struct ConjValues_ *ConjValues;

struct ConjValues2D_;
typedef struct ConjValues2D_ *ConjValues2D;

struct PERMA_;
typedef struct PERMA_ *PERMA;

struct APONTA_;
typedef struct APONTA_ *APONTA;

/********************   Abstract Syntax Classes    ********************/

struct S_
{
  enum { is_Sst } kind;
  union
  {
    struct { Block block_; } sst_;
  } u;
};

S make_Sst(Block p0);

struct Block_
{
  enum { is_LBlock } kind;
  union
  {
    struct { CMDS cmds_; } lblock_;
  } u;
};

Block make_LBlock(CMDS p0);

struct CMDS_
{
  enum { is_CMDSCMD, is_CMDS1 } kind;
  union
  {
    struct { CMD cmd_; } cmdscmd_;
    struct { CMD cmd_; CMDS cmds_; } cmds1_;
  } u;
};

CMDS make_CMDSCMD(CMD p0);
CMDS make_CMDS1(CMD p0, CMDS p1);

struct CMD_
{
  enum { is_CMDATRIB, is_CMDEXP, is_CMDUAI, is_CMDQUANTO, is_CMDPA, is_CMDZOIA, is_CMDVEMCA, is_CMDPERMA, is_CMDTREM, is_CMDFUNC, is_CMDVAILA, is_CMDLABEL, is_CMDSTRUCT, is_CMDAPONTA } kind;
  union
  {
    struct { ATRIB atrib_; } cmdatrib_;
    struct { EXP exp_; } cmdexp_;
    struct { UAI uai_; } cmduai_;
    struct { QUANTO quanto_; } cmdquanto_;
    struct { PA pa_; } cmdpa_;
    struct { ZOIA zoia_; } cmdzoia_;
    struct { VEMCA vemca_; } cmdvemca_;
    struct { PERMA perma_; } cmdperma_;
    struct { TREM trem_; } cmdtrem_;
    struct { FUNC func_; } cmdfunc_;
    struct { VAILA vaila_; } cmdvaila_;
    struct { LABEL label_; } cmdlabel_;
    struct { STRUCT struct_; } cmdstruct_;
    struct { APONTA aponta_; } cmdaponta_;
  } u;
};

CMD make_CMDATRIB(ATRIB p0);
CMD make_CMDEXP(EXP p0);
CMD make_CMDUAI(UAI p0);
CMD make_CMDQUANTO(QUANTO p0);
CMD make_CMDPA(PA p0);
CMD make_CMDZOIA(ZOIA p0);
CMD make_CMDVEMCA(VEMCA p0);
CMD make_CMDPERMA(PERMA p0);
CMD make_CMDTREM(TREM p0);
CMD make_CMDFUNC(FUNC p0);
CMD make_CMDVAILA(VAILA p0);
CMD make_CMDLABEL(LABEL p0);
CMD make_CMDSTRUCT(STRUCT p0);
CMD make_CMDAPONTA(APONTA p0);

struct ATRIB_
{
  enum { is_ATRIB1, is_ATRIB2, is_ATRIB3, is_ATRIB4 } kind;
  union
  {
    struct { Ident ident_; Type type_; VALUE value_; } atrib1_;
    struct { EXP exp_; Ident ident_; Type type_; } atrib2_;
    struct { Ident ident_; VALUE value_; } atrib3_;
    struct { EXP exp_; Ident ident_; } atrib4_;
  } u;
};

ATRIB make_ATRIB1(Type p0, Ident p1, VALUE p2);
ATRIB make_ATRIB2(Type p0, Ident p1, EXP p2);
ATRIB make_ATRIB3(Ident p0, VALUE p1);
ATRIB make_ATRIB4(Ident p0, EXP p1);

struct EXP_
{
  enum { is_EXP1, is_EXP2, is_EXP3, is_EXPVALUE } kind;
  union
  {
    struct { EXP exp_1, exp_2; OPerA opera_; } exp1_;
    struct { EXP exp_1, exp_2; OPerL operl_; } exp2_;
    struct { EXP exp_; } exp3_;
    struct { VALUE value_; } expvalue_;
  } u;
};

EXP make_EXP1(EXP p0, OPerA p1, EXP p2);
EXP make_EXP2(EXP p0, OPerL p1, EXP p2);
EXP make_EXP3(EXP p0);
EXP make_EXPVALUE(VALUE p0);

struct UAI_
{
  enum { is_UAI1, is_UAI2 } kind;
  union
  {
    struct { Block block_; OPL opl_; } uai1_;
    struct { Block block_1, block_2; OPL opl_; } uai2_;
  } u;
};

UAI make_UAI1(OPL p0, Block p1);
UAI make_UAI2(OPL p0, Block p1, Block p2);

struct OPerL_
{
  enum { is_OPerL1, is_OPerL2, is_OPerL3, is_OPerL4, is_OPerL5, is_OPerL6, is_OPerL7, is_OPerL8 } kind;
  union
  {
  } u;
};

OPerL make_OPerL1(void);
OPerL make_OPerL2(void);
OPerL make_OPerL3(void);
OPerL make_OPerL4(void);
OPerL make_OPerL5(void);
OPerL make_OPerL6(void);
OPerL make_OPerL7(void);
OPerL make_OPerL8(void);

struct OPerA_
{
  enum { is_OPerA1, is_OPerA2, is_OPerA3, is_OPerA4 } kind;
  union
  {
  } u;
};

OPerA make_OPerA1(void);
OPerA make_OPerA2(void);
OPerA make_OPerA3(void);
OPerA make_OPerA4(void);

struct OPL_
{
  enum { is_OPL1 } kind;
  union
  {
    struct { EXP exp_1, exp_2; OPerL operl_; } opl1_;
  } u;
};

OPL make_OPL1(EXP p0, OPerL p1, EXP p2);

struct ZOIA_
{
  enum { is_ZOIA1, is_ZOIA2, is_ZOIA3 } kind;
  union
  {
    struct { VALUE value_; } zoia1_;
    struct { VALUE value_1, value_2; } zoia2_;
    struct { VALUE value_1, value_2, value_3; } zoia3_;
  } u;
};

ZOIA make_ZOIA1(VALUE p0);
ZOIA make_ZOIA2(VALUE p0, VALUE p1);
ZOIA make_ZOIA3(VALUE p0, VALUE p1, VALUE p2);

struct VEMCA_
{
  enum { is_VEMCA1 } kind;
  union
  {
    struct { Ident ident_; Type type_; } vemca1_;
  } u;
};

VEMCA make_VEMCA1(Type p0, Ident p1);

struct QUANTO_
{
  enum { is_QUANTO1 } kind;
  union
  {
    struct { Block block_; OPL opl_; } quanto1_;
  } u;
};

QUANTO make_QUANTO1(OPL p0, Block p1);

struct PA_
{
  enum { is_PA1 } kind;
  union
  {
    struct { Block block_; EXP exp_; Ident ident_1, ident_2; OPL opl_; Type type_; VALUE value_; } pa1_;
  } u;
};

PA make_PA1(Type p0, Ident p1, VALUE p2, OPL p3, Ident p4, EXP p5, Block p6);

struct VALUE_
{
  enum { is_VALUEIdent, is_VALUE1, is_VALUE2, is_VALUEString, is_VALUEInteger, is_VALUEDouble } kind;
  union
  {
    struct { Ident ident_; } valueident_;
    struct { EXP exp_; Ident ident_; } value1_;
    struct { EXP exp_1, exp_2; Ident ident_; } value2_;
    struct { String string_; } valuestring_;
    struct { Integer integer_; } valueinteger_;
    struct { Double double_; } valuedouble_;
  } u;
};

VALUE make_VALUEIdent(Ident p0);
VALUE make_VALUE1(Ident p0, EXP p1);
VALUE make_VALUE2(Ident p0, EXP p1, EXP p2);
VALUE make_VALUEString(String p0);
VALUE make_VALUEInteger(Integer p0);
VALUE make_VALUEDouble(Double p0);

struct Type_
{
  enum { is_Type_intero, is_Type_floati, is_Type_stringo } kind;
  union
  {
  } u;
};

Type make_Type_intero(void);
Type make_Type_floati(void);
Type make_Type_stringo(void);

struct TREM_
{
  enum { is_TREM1, is_TREM2, is_TREM3, is_TREM4 } kind;
  union
  {
    struct { Ident ident_; Integer integer_; Type type_; } trem1_;
    struct { ConjValues conjvalues_; Ident ident_; Integer integer_; Type type_; } trem2_;
    struct { Ident ident_; Integer integer_1, integer_2; Type type_; } trem3_;
    struct { ConjValues2D conjvalues2d_; Ident ident_; Integer integer_1, integer_2; Type type_; } trem4_;
  } u;
};

TREM make_TREM1(Type p0, Ident p1, Integer p2);
TREM make_TREM2(Type p0, Ident p1, Integer p2, ConjValues p3);
TREM make_TREM3(Type p0, Ident p1, Integer p2, Integer p3);
TREM make_TREM4(Type p0, Ident p1, Integer p2, Integer p3, ConjValues2D p4);

struct STRUCT_
{
  enum { is_STRUCT1 } kind;
  union
  {
    struct { HeteroElements heteroelements_; Integer integer_; } struct1_;
  } u;
};

STRUCT make_STRUCT1(Integer p0, HeteroElements p1);

struct HeteroElements_
{
  enum { is_HeteroElementsHeteroElement, is_HeteroElements1 } kind;
  union
  {
    struct { HeteroElement heteroelement_; } heteroelementsheteroelement_;
    struct { HeteroElement heteroelement_; HeteroElements heteroelements_; } heteroelements1_;
  } u;
};

HeteroElements make_HeteroElementsHeteroElement(HeteroElement p0);
HeteroElements make_HeteroElements1(HeteroElement p0, HeteroElements p1);

struct HeteroElement_
{
  enum { is_HeteroElementString, is_HeteroElementDouble, is_HeteroElementInteger } kind;
  union
  {
    struct { String string_; } heteroelementstring_;
    struct { Double double_; } heteroelementdouble_;
    struct { Integer integer_; } heteroelementinteger_;
  } u;
};

HeteroElement make_HeteroElementString(String p0);
HeteroElement make_HeteroElementDouble(Double p0);
HeteroElement make_HeteroElementInteger(Integer p0);

struct FUNC_
{
  enum { is_FUNC1, is_FUNC2, is_FUNC3 } kind;
  union
  {
    struct { Block block_; Ident ident_; } func1_;
    struct { Ident ident_; } func2_;
    struct { Ident ident_; VALUE value_; } func3_;
  } u;
};

FUNC make_FUNC1(Ident p0, Block p1);
FUNC make_FUNC2(Ident p0);
FUNC make_FUNC3(Ident p0, VALUE p1);

struct VAILA_
{
  enum { is_VAILA1 } kind;
  union
  {
    struct { Integer integer_; } vaila1_;
  } u;
};

VAILA make_VAILA1(Integer p0);

struct LABEL_
{
  enum { is_LABEL1 } kind;
  union
  {
    struct { Block block_; Integer integer_; } label1_;
  } u;
};

LABEL make_LABEL1(Integer p0, Block p1);

struct ConjValues_
{
  enum { is_ConjValuesVALUE, is_ConjValues1 } kind;
  union
  {
    struct { VALUE value_; } conjvaluesvalue_;
    struct { ConjValues conjvalues_; VALUE value_; } conjvalues1_;
  } u;
};

ConjValues make_ConjValuesVALUE(VALUE p0);
ConjValues make_ConjValues1(VALUE p0, ConjValues p1);

struct ConjValues2D_
{
  enum { is_ConjValues2D1, is_ConjValues2D2 } kind;
  union
  {
    struct { ConjValues conjvalues_; } conjvalues2d1_;
    struct { ConjValues conjvalues_; ConjValues2D conjvalues2d_; } conjvalues2d2_;
  } u;
};

ConjValues2D make_ConjValues2D1(ConjValues p0);
ConjValues2D make_ConjValues2D2(ConjValues p0, ConjValues2D p1);

struct PERMA_
{
  enum { is_LConst } kind;
  union
  {
    struct { Ident ident_; Type type_; VALUE value_; } lconst_;
  } u;
};

PERMA make_LConst(Type p0, Ident p1, VALUE p2);

struct APONTA_
{
  enum { is_LPoint } kind;
  union
  {
    struct { Ident ident_1, ident_2; Type type_; } lpoint_;
  } u;
};

APONTA make_LPoint(Type p0, Ident p1, Ident p2);

/***************************   Cloning   ******************************/

S clone_S(S p);
Block clone_Block(Block p);
CMDS clone_CMDS(CMDS p);
CMD clone_CMD(CMD p);
ATRIB clone_ATRIB(ATRIB p);
EXP clone_EXP(EXP p);
UAI clone_UAI(UAI p);
OPerL clone_OPerL(OPerL p);
OPerA clone_OPerA(OPerA p);
OPL clone_OPL(OPL p);
ZOIA clone_ZOIA(ZOIA p);
VEMCA clone_VEMCA(VEMCA p);
QUANTO clone_QUANTO(QUANTO p);
PA clone_PA(PA p);
VALUE clone_VALUE(VALUE p);
Type clone_Type(Type p);
TREM clone_TREM(TREM p);
STRUCT clone_STRUCT(STRUCT p);
HeteroElements clone_HeteroElements(HeteroElements p);
HeteroElement clone_HeteroElement(HeteroElement p);
FUNC clone_FUNC(FUNC p);
VAILA clone_VAILA(VAILA p);
LABEL clone_LABEL(LABEL p);
ConjValues clone_ConjValues(ConjValues p);
ConjValues2D clone_ConjValues2D(ConjValues2D p);
PERMA clone_PERMA(PERMA p);
APONTA clone_APONTA(APONTA p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_S(S p);
void free_Block(Block p);
void free_CMDS(CMDS p);
void free_CMD(CMD p);
void free_ATRIB(ATRIB p);
void free_EXP(EXP p);
void free_UAI(UAI p);
void free_OPerL(OPerL p);
void free_OPerA(OPerA p);
void free_OPL(OPL p);
void free_ZOIA(ZOIA p);
void free_VEMCA(VEMCA p);
void free_QUANTO(QUANTO p);
void free_PA(PA p);
void free_VALUE(VALUE p);
void free_Type(Type p);
void free_TREM(TREM p);
void free_STRUCT(STRUCT p);
void free_HeteroElements(HeteroElements p);
void free_HeteroElement(HeteroElement p);
void free_FUNC(FUNC p);
void free_VAILA(VAILA p);
void free_LABEL(LABEL p);
void free_ConjValues(ConjValues p);
void free_ConjValues2D(ConjValues2D p);
void free_PERMA(PERMA p);
void free_APONTA(APONTA p);


#endif
