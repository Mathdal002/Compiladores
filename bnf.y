/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the bnf_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE bnf__scan_string(const char *str, yyscan_t scanner);
extern void bnf__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void bnf_lex_destroy(yyscan_t scanner);
extern char* bnf_get_text(yyscan_t scanner);

extern yyscan_t bnf__initialize_lexer(FILE * inp);

/* List reversal functions. */

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  S s_;
  Block block_;
  CMDS cmds_;
  CMD cmd_;
  ATRIB atrib_;
  EXP exp_;
  UAI uai_;
  OPerL operl_;
  OPerA opera_;
  OPL opl_;
  ZOIA zoia_;
  VEMCA vemca_;
  QUANTO quanto_;
  PA pa_;
  VALUE value_;
  Type type_;
  TREM trem_;
  STRUCT struct_;
  HeteroElements heteroelements_;
  HeteroElement heteroelement_;
  FUNC func_;
  VAILA vaila_;
  LABEL label_;
  ConjValues conjvalues_;
  ConjValues2D conjvalues2d_;
  PERMA perma_;
  APONTA aponta_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, bnf_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANGEQ      /* != */
%token          _DAMP        /* && */
%token          _LPAREN      /* ( */
%token          _RPAREN      /* ) */
%token          _STAR        /* * */
%token          _PLUS        /* + */
%token          _COMMA       /* , */
%token          _MINUS       /* - */
%token          _SLASH       /* / */
%token          _COLON       /* : */
%token          _SEMI        /* ; */
%token          _LT          /* < */
%token          _LDARROW     /* <= */
%token          _LTGT        /* <> */
%token          _EQ          /* = */
%token          _DEQ         /* == */
%token          _GT          /* > */
%token          _GTEQ        /* >= */
%token          _KW_23       /* Funciona_Assim */
%token          _KW_Istrut   /* Istrut */
%token          _KW_LABEL    /* LABEL */
%token          _KW_Pa       /* Pa */
%token          _KW_Perma    /* Perma */
%token          _KW_Quanto   /* Quanto */
%token          _KW_So       /* So */
%token          _KW_Uai      /* Uai */
%token          _KW_Vaila    /* Vaila */
%token          _KW_Vemca    /* Vemca */
%token          _KW_Zoia     /* Zoia */
%token          _LBRACK      /* [ */
%token          _RBRACK      /* ] */
%token          _KW_ceu      /* ceu */
%token          _KW_deus     /* deus */
%token          _KW_do       /* do */
%token          _KW_floati   /* floati */
%token          _KW_intero   /* intero */
%token          _KW_main     /* main */
%token          _KW_stringo  /* stringo */
%token          _LBRACE      /* { */
%token          _BAR         /* | */
%token          _RBRACE      /* } */
%token<_string> _STRING_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <s_> S
%type <block_> Block
%type <cmds_> CMDS
%type <cmd_> CMD
%type <atrib_> ATRIB
%type <exp_> EXP
%type <uai_> UAI
%type <operl_> OPerL
%type <opera_> OPerA
%type <opl_> OPL
%type <zoia_> ZOIA
%type <vemca_> VEMCA
%type <quanto_> QUANTO
%type <pa_> PA
%type <value_> VALUE
%type <type_> Type
%type <trem_> TREM
%type <struct_> STRUCT
%type <heteroelements_> HeteroElements
%type <heteroelement_> HeteroElement
%type <func_> FUNC
%type <vaila_> VAILA
%type <label_> LABEL
%type <conjvalues_> ConjValues
%type <conjvalues2d_> ConjValues2D
%type <perma_> PERMA
%type <aponta_> APONTA

%start S

%%

S : _KW_main _KW_deus _KW_do _KW_ceu Block { $$ = make_Sst($5); result->s_ = $$; }
;
Block : _LBRACE CMDS _RBRACE { $$ = make_LBlock($2); result->block_ = $$; }
;
CMDS : CMD { $$ = make_CMDSCMD($1); result->cmds_ = $$; }
  | CMD CMDS { $$ = make_CMDS1($1, $2); result->cmds_ = $$; }
;
CMD : ATRIB { $$ = make_CMDATRIB($1); result->cmd_ = $$; }
  | EXP { $$ = make_CMDEXP($1); result->cmd_ = $$; }
  | UAI { $$ = make_CMDUAI($1); result->cmd_ = $$; }
  | QUANTO { $$ = make_CMDQUANTO($1); result->cmd_ = $$; }
  | PA { $$ = make_CMDPA($1); result->cmd_ = $$; }
  | ZOIA { $$ = make_CMDZOIA($1); result->cmd_ = $$; }
  | VEMCA { $$ = make_CMDVEMCA($1); result->cmd_ = $$; }
  | PERMA { $$ = make_CMDPERMA($1); result->cmd_ = $$; }
  | TREM { $$ = make_CMDTREM($1); result->cmd_ = $$; }
  | FUNC { $$ = make_CMDFUNC($1); result->cmd_ = $$; }
  | VAILA { $$ = make_CMDVAILA($1); result->cmd_ = $$; }
  | LABEL { $$ = make_CMDLABEL($1); result->cmd_ = $$; }
  | STRUCT { $$ = make_CMDSTRUCT($1); result->cmd_ = $$; }
  | APONTA { $$ = make_CMDAPONTA($1); result->cmd_ = $$; }
;
ATRIB : Type _IDENT_ _EQ VALUE _SEMI { $$ = make_ATRIB1($1, $2, $4); result->atrib_ = $$; }
  | Type _IDENT_ _EQ EXP _SEMI { $$ = make_ATRIB2($1, $2, $4); result->atrib_ = $$; }
  | _IDENT_ _EQ VALUE _SEMI { $$ = make_ATRIB3($1, $3); result->atrib_ = $$; }
  | _IDENT_ _EQ EXP _SEMI { $$ = make_ATRIB4($1, $3); result->atrib_ = $$; }
;
EXP : EXP OPerA EXP { $$ = make_EXP1($1, $2, $3); result->exp_ = $$; }
  | EXP OPerL EXP { $$ = make_EXP2($1, $2, $3); result->exp_ = $$; }
  | _LPAREN EXP _RPAREN { $$ = make_EXP3($2); result->exp_ = $$; }
  | VALUE { $$ = make_EXPVALUE($1); result->exp_ = $$; }
;
UAI : _KW_Uai _LPAREN OPL _RPAREN Block { $$ = make_UAI1($3, $5); result->uai_ = $$; }
  | _KW_Uai _LPAREN OPL _RPAREN Block _KW_So Block { $$ = make_UAI2($3, $5, $7); result->uai_ = $$; }
;
OPerL : _GT { $$ = make_OPerL1(); result->operl_ = $$; }
  | _GTEQ { $$ = make_OPerL2(); result->operl_ = $$; }
  | _LT { $$ = make_OPerL3(); result->operl_ = $$; }
  | _LDARROW { $$ = make_OPerL4(); result->operl_ = $$; }
  | _DEQ { $$ = make_OPerL5(); result->operl_ = $$; }
  | _LTGT { $$ = make_OPerL6(); result->operl_ = $$; }
  | _BANGEQ { $$ = make_OPerL7(); result->operl_ = $$; }
  | _DAMP { $$ = make_OPerL8(); result->operl_ = $$; }
;
OPerA : _SLASH { $$ = make_OPerA1(); result->opera_ = $$; }
  | _STAR { $$ = make_OPerA2(); result->opera_ = $$; }
  | _PLUS { $$ = make_OPerA3(); result->opera_ = $$; }
  | _MINUS { $$ = make_OPerA4(); result->opera_ = $$; }
;
OPL : EXP OPerL EXP { $$ = make_OPL1($1, $2, $3); result->opl_ = $$; }
;
ZOIA : _KW_Zoia _LPAREN VALUE _RPAREN _SEMI { $$ = make_ZOIA1($3); result->zoia_ = $$; }
  | _KW_Zoia _LPAREN VALUE _COMMA VALUE _RPAREN _SEMI { $$ = make_ZOIA2($3, $5); result->zoia_ = $$; }
  | _KW_Zoia _LPAREN VALUE _COMMA VALUE _COMMA VALUE _RPAREN _SEMI { $$ = make_ZOIA3($3, $5, $7); result->zoia_ = $$; }
;
VEMCA : _KW_Vemca _LPAREN Type _IDENT_ _RPAREN _SEMI { $$ = make_VEMCA1($3, $4); result->vemca_ = $$; }
;
QUANTO : _KW_Quanto _LPAREN OPL _RPAREN Block { $$ = make_QUANTO1($3, $5); result->quanto_ = $$; }
;
PA : _KW_Pa _LPAREN Type _IDENT_ _EQ VALUE _BAR OPL _BAR _IDENT_ _EQ EXP _RPAREN Block { $$ = make_PA1($3, $4, $6, $8, $10, $12, $14); result->pa_ = $$; }
;
VALUE : _IDENT_ { $$ = make_VALUEIdent($1); result->value_ = $$; }
  | _IDENT_ _LBRACK EXP _RBRACK { $$ = make_VALUE1($1, $3); result->value_ = $$; }
  | _IDENT_ _LBRACK EXP _RBRACK _LBRACK EXP _RBRACK { $$ = make_VALUE2($1, $3, $6); result->value_ = $$; }
  | _STRING_ { $$ = make_VALUEString($1); result->value_ = $$; }
  | _INTEGER_ { $$ = make_VALUEInteger($1); result->value_ = $$; }
  | _DOUBLE_ { $$ = make_VALUEDouble($1); result->value_ = $$; }
;
Type : _KW_intero { $$ = make_Type_intero(); result->type_ = $$; }
  | _KW_floati { $$ = make_Type_floati(); result->type_ = $$; }
  | _KW_stringo { $$ = make_Type_stringo(); result->type_ = $$; }
;
TREM : Type _IDENT_ _LBRACK _INTEGER_ _RBRACK _SEMI { $$ = make_TREM1($1, $2, $4); result->trem_ = $$; }
  | Type _IDENT_ _LBRACK _INTEGER_ _RBRACK _EQ _LBRACK ConjValues _RBRACK _SEMI { $$ = make_TREM2($1, $2, $4, $8); result->trem_ = $$; }
  | Type _IDENT_ _LBRACK _INTEGER_ _RBRACK _LBRACK _INTEGER_ _RBRACK _SEMI { $$ = make_TREM3($1, $2, $4, $7); result->trem_ = $$; }
  | Type _IDENT_ _LBRACK _INTEGER_ _RBRACK _LBRACK _INTEGER_ _RBRACK _EQ _LBRACK ConjValues2D _RBRACK _SEMI { $$ = make_TREM4($1, $2, $4, $7, $11); result->trem_ = $$; }
;
STRUCT : _KW_Istrut _LBRACK _INTEGER_ _RBRACK _EQ _LBRACE HeteroElements _RBRACE _SEMI { $$ = make_STRUCT1($3, $7); result->struct_ = $$; }
;
HeteroElements : HeteroElement { $$ = make_HeteroElementsHeteroElement($1); result->heteroelements_ = $$; }
  | HeteroElement _COMMA HeteroElements { $$ = make_HeteroElements1($1, $3); result->heteroelements_ = $$; }
;
HeteroElement : _STRING_ { $$ = make_HeteroElementString($1); result->heteroelement_ = $$; }
  | _DOUBLE_ { $$ = make_HeteroElementDouble($1); result->heteroelement_ = $$; }
  | _INTEGER_ { $$ = make_HeteroElementInteger($1); result->heteroelement_ = $$; }
;
FUNC : _KW_23 _IDENT_ _LPAREN _RPAREN Block { $$ = make_FUNC1($2, $5); result->func_ = $$; }
  | _IDENT_ _LPAREN _RPAREN _SEMI { $$ = make_FUNC2($1); result->func_ = $$; }
  | _IDENT_ _LPAREN VALUE _RPAREN { $$ = make_FUNC3($1, $3); result->func_ = $$; }
;
VAILA : _KW_Vaila _INTEGER_ _SEMI { $$ = make_VAILA1($2); result->vaila_ = $$; }
;
LABEL : _KW_LABEL _INTEGER_ _COLON Block { $$ = make_LABEL1($2, $4); result->label_ = $$; }
;
ConjValues : VALUE { $$ = make_ConjValuesVALUE($1); result->conjvalues_ = $$; }
  | VALUE _COMMA ConjValues { $$ = make_ConjValues1($1, $3); result->conjvalues_ = $$; }
;
ConjValues2D : _LBRACK ConjValues _RBRACK { $$ = make_ConjValues2D1($2); result->conjvalues2d_ = $$; }
  | _LBRACK ConjValues _RBRACK _COMMA ConjValues2D { $$ = make_ConjValues2D2($2, $5); result->conjvalues2d_ = $$; }
;
PERMA : _KW_Perma Type _IDENT_ _EQ VALUE _SEMI { $$ = make_LConst($2, $3, $5); result->perma_ = $$; }
;
APONTA : Type _STAR _IDENT_ _EQ _IDENT_ _SEMI { $$ = make_LPoint($1, $3, $5); result->aponta_ = $$; }
;

%%


/* Entrypoint: parse S from file. */
S pS(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.s_;
  }
}

/* Entrypoint: parse S from string. */
S psS(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.s_;
  }
}

/* Entrypoint: parse Block from file. */
Block pBlock(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.block_;
  }
}

/* Entrypoint: parse Block from string. */
Block psBlock(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.block_;
  }
}

/* Entrypoint: parse CMDS from file. */
CMDS pCMDS(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmds_;
  }
}

/* Entrypoint: parse CMDS from string. */
CMDS psCMDS(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmds_;
  }
}

/* Entrypoint: parse CMD from file. */
CMD pCMD(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse CMD from string. */
CMD psCMD(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse ATRIB from file. */
ATRIB pATRIB(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atrib_;
  }
}

/* Entrypoint: parse ATRIB from string. */
ATRIB psATRIB(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atrib_;
  }
}

/* Entrypoint: parse EXP from file. */
EXP pEXP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse EXP from string. */
EXP psEXP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse UAI from file. */
UAI pUAI(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.uai_;
  }
}

/* Entrypoint: parse UAI from string. */
UAI psUAI(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.uai_;
  }
}

/* Entrypoint: parse OPerL from file. */
OPerL pOPerL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operl_;
  }
}

/* Entrypoint: parse OPerL from string. */
OPerL psOPerL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operl_;
  }
}

/* Entrypoint: parse OPerA from file. */
OPerA pOPerA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opera_;
  }
}

/* Entrypoint: parse OPerA from string. */
OPerA psOPerA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opera_;
  }
}

/* Entrypoint: parse OPL from file. */
OPL pOPL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opl_;
  }
}

/* Entrypoint: parse OPL from string. */
OPL psOPL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opl_;
  }
}

/* Entrypoint: parse ZOIA from file. */
ZOIA pZOIA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.zoia_;
  }
}

/* Entrypoint: parse ZOIA from string. */
ZOIA psZOIA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.zoia_;
  }
}

/* Entrypoint: parse VEMCA from file. */
VEMCA pVEMCA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vemca_;
  }
}

/* Entrypoint: parse VEMCA from string. */
VEMCA psVEMCA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vemca_;
  }
}

/* Entrypoint: parse QUANTO from file. */
QUANTO pQUANTO(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.quanto_;
  }
}

/* Entrypoint: parse QUANTO from string. */
QUANTO psQUANTO(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.quanto_;
  }
}

/* Entrypoint: parse PA from file. */
PA pPA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pa_;
  }
}

/* Entrypoint: parse PA from string. */
PA psPA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pa_;
  }
}

/* Entrypoint: parse VALUE from file. */
VALUE pVALUE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.value_;
  }
}

/* Entrypoint: parse VALUE from string. */
VALUE psVALUE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.value_;
  }
}

/* Entrypoint: parse Type from file. */
Type pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type from string. */
Type psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse TREM from file. */
TREM pTREM(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.trem_;
  }
}

/* Entrypoint: parse TREM from string. */
TREM psTREM(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.trem_;
  }
}

/* Entrypoint: parse STRUCT from file. */
STRUCT pSTRUCT(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.struct_;
  }
}

/* Entrypoint: parse STRUCT from string. */
STRUCT psSTRUCT(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.struct_;
  }
}

/* Entrypoint: parse HeteroElements from file. */
HeteroElements pHeteroElements(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.heteroelements_;
  }
}

/* Entrypoint: parse HeteroElements from string. */
HeteroElements psHeteroElements(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.heteroelements_;
  }
}

/* Entrypoint: parse HeteroElement from file. */
HeteroElement pHeteroElement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.heteroelement_;
  }
}

/* Entrypoint: parse HeteroElement from string. */
HeteroElement psHeteroElement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.heteroelement_;
  }
}

/* Entrypoint: parse FUNC from file. */
FUNC pFUNC(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.func_;
  }
}

/* Entrypoint: parse FUNC from string. */
FUNC psFUNC(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.func_;
  }
}

/* Entrypoint: parse VAILA from file. */
VAILA pVAILA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vaila_;
  }
}

/* Entrypoint: parse VAILA from string. */
VAILA psVAILA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vaila_;
  }
}

/* Entrypoint: parse LABEL from file. */
LABEL pLABEL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.label_;
  }
}

/* Entrypoint: parse LABEL from string. */
LABEL psLABEL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.label_;
  }
}

/* Entrypoint: parse ConjValues from file. */
ConjValues pConjValues(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjvalues_;
  }
}

/* Entrypoint: parse ConjValues from string. */
ConjValues psConjValues(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjvalues_;
  }
}

/* Entrypoint: parse ConjValues2D from file. */
ConjValues2D pConjValues2D(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjvalues2d_;
  }
}

/* Entrypoint: parse ConjValues2D from string. */
ConjValues2D psConjValues2D(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjvalues2d_;
  }
}

/* Entrypoint: parse PERMA from file. */
PERMA pPERMA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.perma_;
  }
}

/* Entrypoint: parse PERMA from string. */
PERMA psPERMA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.perma_;
  }
}

/* Entrypoint: parse APONTA from file. */
APONTA pAPONTA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.aponta_;
  }
}

/* Entrypoint: parse APONTA from string. */
APONTA psAPONTA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnf__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnf__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnf__delete_buffer(buf, scanner);
  bnf_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.aponta_;
  }
}



