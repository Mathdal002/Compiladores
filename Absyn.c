/* File generated by the BNF Converter (bnfc 2.9.5). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   Sst    ********************/

S make_Sst(Block p1)
{
    S tmp = (S) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Sst!\n");
        exit(1);
    }
    tmp->kind = is_Sst;
    tmp->u.sst_.block_ = p1;
    return tmp;
}

/********************   LBlock    ********************/

Block make_LBlock(CMDS p1)
{
    Block tmp = (Block) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LBlock!\n");
        exit(1);
    }
    tmp->kind = is_LBlock;
    tmp->u.lblock_.cmds_ = p1;
    return tmp;
}

/********************   CMDSCMD    ********************/

CMDS make_CMDSCMD(CMD p1)
{
    CMDS tmp = (CMDS) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDSCMD!\n");
        exit(1);
    }
    tmp->kind = is_CMDSCMD;
    tmp->u.cmdscmd_.cmd_ = p1;
    return tmp;
}

/********************   CMDS1    ********************/

CMDS make_CMDS1(CMD p1, CMDS p2)
{
    CMDS tmp = (CMDS) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDS1!\n");
        exit(1);
    }
    tmp->kind = is_CMDS1;
    tmp->u.cmds1_.cmd_ = p1;
    tmp->u.cmds1_.cmds_ = p2;
    return tmp;
}

/********************   CMDATRIB    ********************/

CMD make_CMDATRIB(ATRIB p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDATRIB!\n");
        exit(1);
    }
    tmp->kind = is_CMDATRIB;
    tmp->u.cmdatrib_.atrib_ = p1;
    return tmp;
}

/********************   CMDEXP    ********************/

CMD make_CMDEXP(EXP p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDEXP!\n");
        exit(1);
    }
    tmp->kind = is_CMDEXP;
    tmp->u.cmdexp_.exp_ = p1;
    return tmp;
}

/********************   CMDUAI    ********************/

CMD make_CMDUAI(UAI p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDUAI!\n");
        exit(1);
    }
    tmp->kind = is_CMDUAI;
    tmp->u.cmduai_.uai_ = p1;
    return tmp;
}

/********************   CMDQUANTO    ********************/

CMD make_CMDQUANTO(QUANTO p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDQUANTO!\n");
        exit(1);
    }
    tmp->kind = is_CMDQUANTO;
    tmp->u.cmdquanto_.quanto_ = p1;
    return tmp;
}

/********************   CMDPA    ********************/

CMD make_CMDPA(PA p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDPA!\n");
        exit(1);
    }
    tmp->kind = is_CMDPA;
    tmp->u.cmdpa_.pa_ = p1;
    return tmp;
}

/********************   CMDZOIA    ********************/

CMD make_CMDZOIA(ZOIA p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDZOIA!\n");
        exit(1);
    }
    tmp->kind = is_CMDZOIA;
    tmp->u.cmdzoia_.zoia_ = p1;
    return tmp;
}

/********************   CMDVEMCA    ********************/

CMD make_CMDVEMCA(VEMCA p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDVEMCA!\n");
        exit(1);
    }
    tmp->kind = is_CMDVEMCA;
    tmp->u.cmdvemca_.vemca_ = p1;
    return tmp;
}

/********************   CMDPERMA    ********************/

CMD make_CMDPERMA(PERMA p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDPERMA!\n");
        exit(1);
    }
    tmp->kind = is_CMDPERMA;
    tmp->u.cmdperma_.perma_ = p1;
    return tmp;
}

/********************   CMDTREM    ********************/

CMD make_CMDTREM(TREM p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDTREM!\n");
        exit(1);
    }
    tmp->kind = is_CMDTREM;
    tmp->u.cmdtrem_.trem_ = p1;
    return tmp;
}

/********************   CMDFUNC    ********************/

CMD make_CMDFUNC(FUNC p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDFUNC!\n");
        exit(1);
    }
    tmp->kind = is_CMDFUNC;
    tmp->u.cmdfunc_.func_ = p1;
    return tmp;
}

/********************   CMDVAILA    ********************/

CMD make_CMDVAILA(VAILA p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDVAILA!\n");
        exit(1);
    }
    tmp->kind = is_CMDVAILA;
    tmp->u.cmdvaila_.vaila_ = p1;
    return tmp;
}

/********************   CMDLABEL    ********************/

CMD make_CMDLABEL(LABEL p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDLABEL!\n");
        exit(1);
    }
    tmp->kind = is_CMDLABEL;
    tmp->u.cmdlabel_.label_ = p1;
    return tmp;
}

/********************   CMDSTRUCT    ********************/

CMD make_CMDSTRUCT(STRUCT p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDSTRUCT!\n");
        exit(1);
    }
    tmp->kind = is_CMDSTRUCT;
    tmp->u.cmdstruct_.struct_ = p1;
    return tmp;
}

/********************   CMDAPONTA    ********************/

CMD make_CMDAPONTA(APONTA p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDAPONTA!\n");
        exit(1);
    }
    tmp->kind = is_CMDAPONTA;
    tmp->u.cmdaponta_.aponta_ = p1;
    return tmp;
}

/********************   ATRIB1    ********************/

ATRIB make_ATRIB1(Type p1, Ident p2, VALUE p3)
{
    ATRIB tmp = (ATRIB) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ATRIB1!\n");
        exit(1);
    }
    tmp->kind = is_ATRIB1;
    tmp->u.atrib1_.type_ = p1;
    tmp->u.atrib1_.ident_ = p2;
    tmp->u.atrib1_.value_ = p3;
    return tmp;
}

/********************   ATRIB2    ********************/

ATRIB make_ATRIB2(Type p1, Ident p2, EXP p3)
{
    ATRIB tmp = (ATRIB) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ATRIB2!\n");
        exit(1);
    }
    tmp->kind = is_ATRIB2;
    tmp->u.atrib2_.type_ = p1;
    tmp->u.atrib2_.ident_ = p2;
    tmp->u.atrib2_.exp_ = p3;
    return tmp;
}

/********************   ATRIB3    ********************/

ATRIB make_ATRIB3(Ident p1, VALUE p2)
{
    ATRIB tmp = (ATRIB) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ATRIB3!\n");
        exit(1);
    }
    tmp->kind = is_ATRIB3;
    tmp->u.atrib3_.ident_ = p1;
    tmp->u.atrib3_.value_ = p2;
    return tmp;
}

/********************   ATRIB4    ********************/

ATRIB make_ATRIB4(Ident p1, EXP p2)
{
    ATRIB tmp = (ATRIB) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ATRIB4!\n");
        exit(1);
    }
    tmp->kind = is_ATRIB4;
    tmp->u.atrib4_.ident_ = p1;
    tmp->u.atrib4_.exp_ = p2;
    return tmp;
}

/********************   EXP1    ********************/

EXP make_EXP1(EXP p1, OPerA p2, EXP p3)
{
    EXP tmp = (EXP) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EXP1!\n");
        exit(1);
    }
    tmp->kind = is_EXP1;
    tmp->u.exp1_.exp_1 = p1;
    tmp->u.exp1_.opera_ = p2;
    tmp->u.exp1_.exp_2 = p3;
    return tmp;
}

/********************   EXP2    ********************/

EXP make_EXP2(EXP p1, OPerL p2, EXP p3)
{
    EXP tmp = (EXP) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EXP2!\n");
        exit(1);
    }
    tmp->kind = is_EXP2;
    tmp->u.exp2_.exp_1 = p1;
    tmp->u.exp2_.operl_ = p2;
    tmp->u.exp2_.exp_2 = p3;
    return tmp;
}

/********************   EXP3    ********************/

EXP make_EXP3(EXP p1)
{
    EXP tmp = (EXP) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EXP3!\n");
        exit(1);
    }
    tmp->kind = is_EXP3;
    tmp->u.exp3_.exp_ = p1;
    return tmp;
}

/********************   EXPVALUE    ********************/

EXP make_EXPVALUE(VALUE p1)
{
    EXP tmp = (EXP) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EXPVALUE!\n");
        exit(1);
    }
    tmp->kind = is_EXPVALUE;
    tmp->u.expvalue_.value_ = p1;
    return tmp;
}

/********************   UAI1    ********************/

UAI make_UAI1(OPL p1, Block p2)
{
    UAI tmp = (UAI) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating UAI1!\n");
        exit(1);
    }
    tmp->kind = is_UAI1;
    tmp->u.uai1_.opl_ = p1;
    tmp->u.uai1_.block_ = p2;
    return tmp;
}

/********************   UAI2    ********************/

UAI make_UAI2(OPL p1, Block p2, Block p3)
{
    UAI tmp = (UAI) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating UAI2!\n");
        exit(1);
    }
    tmp->kind = is_UAI2;
    tmp->u.uai2_.opl_ = p1;
    tmp->u.uai2_.block_1 = p2;
    tmp->u.uai2_.block_2 = p3;
    return tmp;
}

/********************   OPerL1    ********************/

OPerL make_OPerL1()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL1!\n");
        exit(1);
    }
    tmp->kind = is_OPerL1;
    return tmp;
}

/********************   OPerL2    ********************/

OPerL make_OPerL2()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL2!\n");
        exit(1);
    }
    tmp->kind = is_OPerL2;
    return tmp;
}

/********************   OPerL3    ********************/

OPerL make_OPerL3()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL3!\n");
        exit(1);
    }
    tmp->kind = is_OPerL3;
    return tmp;
}

/********************   OPerL4    ********************/

OPerL make_OPerL4()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL4!\n");
        exit(1);
    }
    tmp->kind = is_OPerL4;
    return tmp;
}

/********************   OPerL5    ********************/

OPerL make_OPerL5()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL5!\n");
        exit(1);
    }
    tmp->kind = is_OPerL5;
    return tmp;
}

/********************   OPerL6    ********************/

OPerL make_OPerL6()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL6!\n");
        exit(1);
    }
    tmp->kind = is_OPerL6;
    return tmp;
}

/********************   OPerL7    ********************/

OPerL make_OPerL7()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL7!\n");
        exit(1);
    }
    tmp->kind = is_OPerL7;
    return tmp;
}

/********************   OPerL8    ********************/

OPerL make_OPerL8()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL8!\n");
        exit(1);
    }
    tmp->kind = is_OPerL8;
    return tmp;
}

/********************   OPerA1    ********************/

OPerA make_OPerA1()
{
    OPerA tmp = (OPerA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerA1!\n");
        exit(1);
    }
    tmp->kind = is_OPerA1;
    return tmp;
}

/********************   OPerA2    ********************/

OPerA make_OPerA2()
{
    OPerA tmp = (OPerA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerA2!\n");
        exit(1);
    }
    tmp->kind = is_OPerA2;
    return tmp;
}

/********************   OPerA3    ********************/

OPerA make_OPerA3()
{
    OPerA tmp = (OPerA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerA3!\n");
        exit(1);
    }
    tmp->kind = is_OPerA3;
    return tmp;
}

/********************   OPerA4    ********************/

OPerA make_OPerA4()
{
    OPerA tmp = (OPerA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerA4!\n");
        exit(1);
    }
    tmp->kind = is_OPerA4;
    return tmp;
}

/********************   OPL1    ********************/

OPL make_OPL1(EXP p1, OPerL p2, EXP p3)
{
    OPL tmp = (OPL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPL1!\n");
        exit(1);
    }
    tmp->kind = is_OPL1;
    tmp->u.opl1_.exp_1 = p1;
    tmp->u.opl1_.operl_ = p2;
    tmp->u.opl1_.exp_2 = p3;
    return tmp;
}

/********************   ZOIA1    ********************/

ZOIA make_ZOIA1(VALUE p1)
{
    ZOIA tmp = (ZOIA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ZOIA1!\n");
        exit(1);
    }
    tmp->kind = is_ZOIA1;
    tmp->u.zoia1_.value_ = p1;
    return tmp;
}

/********************   ZOIA2    ********************/

ZOIA make_ZOIA2(VALUE p1, VALUE p2)
{
    ZOIA tmp = (ZOIA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ZOIA2!\n");
        exit(1);
    }
    tmp->kind = is_ZOIA2;
    tmp->u.zoia2_.value_1 = p1;
    tmp->u.zoia2_.value_2 = p2;
    return tmp;
}

/********************   ZOIA3    ********************/

ZOIA make_ZOIA3(VALUE p1, VALUE p2, VALUE p3)
{
    ZOIA tmp = (ZOIA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ZOIA3!\n");
        exit(1);
    }
    tmp->kind = is_ZOIA3;
    tmp->u.zoia3_.value_1 = p1;
    tmp->u.zoia3_.value_2 = p2;
    tmp->u.zoia3_.value_3 = p3;
    return tmp;
}

/********************   VEMCA1    ********************/

VEMCA make_VEMCA1(Type p1, Ident p2)
{
    VEMCA tmp = (VEMCA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VEMCA1!\n");
        exit(1);
    }
    tmp->kind = is_VEMCA1;
    tmp->u.vemca1_.type_ = p1;
    tmp->u.vemca1_.ident_ = p2;
    return tmp;
}

/********************   QUANTO1    ********************/

QUANTO make_QUANTO1(OPL p1, Block p2)
{
    QUANTO tmp = (QUANTO) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating QUANTO1!\n");
        exit(1);
    }
    tmp->kind = is_QUANTO1;
    tmp->u.quanto1_.opl_ = p1;
    tmp->u.quanto1_.block_ = p2;
    return tmp;
}

/********************   PA1    ********************/

PA make_PA1(Type p1, Ident p2, VALUE p3, OPL p4, Ident p5, EXP p6, Block p7)
{
    PA tmp = (PA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PA1!\n");
        exit(1);
    }
    tmp->kind = is_PA1;
    tmp->u.pa1_.type_ = p1;
    tmp->u.pa1_.ident_1 = p2;
    tmp->u.pa1_.value_ = p3;
    tmp->u.pa1_.opl_ = p4;
    tmp->u.pa1_.ident_2 = p5;
    tmp->u.pa1_.exp_ = p6;
    tmp->u.pa1_.block_ = p7;
    return tmp;
}

/********************   VALUEIdent    ********************/

VALUE make_VALUEIdent(Ident p1)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUEIdent!\n");
        exit(1);
    }
    tmp->kind = is_VALUEIdent;
    tmp->u.valueident_.ident_ = p1;
    return tmp;
}

/********************   VALUE1    ********************/

VALUE make_VALUE1(Ident p1, EXP p2)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUE1!\n");
        exit(1);
    }
    tmp->kind = is_VALUE1;
    tmp->u.value1_.ident_ = p1;
    tmp->u.value1_.exp_ = p2;
    return tmp;
}

/********************   VALUE2    ********************/

VALUE make_VALUE2(Ident p1, EXP p2, EXP p3)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUE2!\n");
        exit(1);
    }
    tmp->kind = is_VALUE2;
    tmp->u.value2_.ident_ = p1;
    tmp->u.value2_.exp_1 = p2;
    tmp->u.value2_.exp_2 = p3;
    return tmp;
}

/********************   VALUEString    ********************/

VALUE make_VALUEString(String p1)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUEString!\n");
        exit(1);
    }
    tmp->kind = is_VALUEString;
    tmp->u.valuestring_.string_ = p1;
    return tmp;
}

/********************   VALUEInteger    ********************/

VALUE make_VALUEInteger(Integer p1)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUEInteger!\n");
        exit(1);
    }
    tmp->kind = is_VALUEInteger;
    tmp->u.valueinteger_.integer_ = p1;
    return tmp;
}

/********************   VALUEDouble    ********************/

VALUE make_VALUEDouble(Double p1)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUEDouble!\n");
        exit(1);
    }
    tmp->kind = is_VALUEDouble;
    tmp->u.valuedouble_.double_ = p1;
    return tmp;
}

/********************   Type_intero    ********************/

Type make_Type_intero()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_intero!\n");
        exit(1);
    }
    tmp->kind = is_Type_intero;
    return tmp;
}

/********************   Type_floati    ********************/

Type make_Type_floati()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_floati!\n");
        exit(1);
    }
    tmp->kind = is_Type_floati;
    return tmp;
}

/********************   Type_stringo    ********************/

Type make_Type_stringo()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_stringo!\n");
        exit(1);
    }
    tmp->kind = is_Type_stringo;
    return tmp;
}

/********************   TREM1    ********************/

TREM make_TREM1(Type p1, Ident p2, Integer p3)
{
    TREM tmp = (TREM) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TREM1!\n");
        exit(1);
    }
    tmp->kind = is_TREM1;
    tmp->u.trem1_.type_ = p1;
    tmp->u.trem1_.ident_ = p2;
    tmp->u.trem1_.integer_ = p3;
    return tmp;
}

/********************   TREM2    ********************/

TREM make_TREM2(Type p1, Ident p2, Integer p3, ConjValues p4)
{
    TREM tmp = (TREM) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TREM2!\n");
        exit(1);
    }
    tmp->kind = is_TREM2;
    tmp->u.trem2_.type_ = p1;
    tmp->u.trem2_.ident_ = p2;
    tmp->u.trem2_.integer_ = p3;
    tmp->u.trem2_.conjvalues_ = p4;
    return tmp;
}

/********************   TREM3    ********************/

TREM make_TREM3(Type p1, Ident p2, Integer p3, Integer p4)
{
    TREM tmp = (TREM) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TREM3!\n");
        exit(1);
    }
    tmp->kind = is_TREM3;
    tmp->u.trem3_.type_ = p1;
    tmp->u.trem3_.ident_ = p2;
    tmp->u.trem3_.integer_1 = p3;
    tmp->u.trem3_.integer_2 = p4;
    return tmp;
}

/********************   TREM4    ********************/

TREM make_TREM4(Type p1, Ident p2, Integer p3, Integer p4, ConjValues2D p5)
{
    TREM tmp = (TREM) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TREM4!\n");
        exit(1);
    }
    tmp->kind = is_TREM4;
    tmp->u.trem4_.type_ = p1;
    tmp->u.trem4_.ident_ = p2;
    tmp->u.trem4_.integer_1 = p3;
    tmp->u.trem4_.integer_2 = p4;
    tmp->u.trem4_.conjvalues2d_ = p5;
    return tmp;
}

/********************   STRUCT1    ********************/

STRUCT make_STRUCT1(Integer p1, HeteroElements p2)
{
    STRUCT tmp = (STRUCT) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating STRUCT1!\n");
        exit(1);
    }
    tmp->kind = is_STRUCT1;
    tmp->u.struct1_.integer_ = p1;
    tmp->u.struct1_.heteroelements_ = p2;
    return tmp;
}

/********************   HeteroElementsHeteroElement    ********************/

HeteroElements make_HeteroElementsHeteroElement(HeteroElement p1)
{
    HeteroElements tmp = (HeteroElements) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElementsHeteroElement!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElementsHeteroElement;
    tmp->u.heteroelementsheteroelement_.heteroelement_ = p1;
    return tmp;
}

/********************   HeteroElements1    ********************/

HeteroElements make_HeteroElements1(HeteroElement p1, HeteroElements p2)
{
    HeteroElements tmp = (HeteroElements) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElements1!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElements1;
    tmp->u.heteroelements1_.heteroelement_ = p1;
    tmp->u.heteroelements1_.heteroelements_ = p2;
    return tmp;
}

/********************   HeteroElementString    ********************/

HeteroElement make_HeteroElementString(String p1)
{
    HeteroElement tmp = (HeteroElement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElementString!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElementString;
    tmp->u.heteroelementstring_.string_ = p1;
    return tmp;
}

/********************   HeteroElementDouble    ********************/

HeteroElement make_HeteroElementDouble(Double p1)
{
    HeteroElement tmp = (HeteroElement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElementDouble!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElementDouble;
    tmp->u.heteroelementdouble_.double_ = p1;
    return tmp;
}

/********************   HeteroElementInteger    ********************/

HeteroElement make_HeteroElementInteger(Integer p1)
{
    HeteroElement tmp = (HeteroElement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElementInteger!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElementInteger;
    tmp->u.heteroelementinteger_.integer_ = p1;
    return tmp;
}

/********************   FUNC1    ********************/

FUNC make_FUNC1(Ident p1, Block p2)
{
    FUNC tmp = (FUNC) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FUNC1!\n");
        exit(1);
    }
    tmp->kind = is_FUNC1;
    tmp->u.func1_.ident_ = p1;
    tmp->u.func1_.block_ = p2;
    return tmp;
}

/********************   FUNC2    ********************/

FUNC make_FUNC2(Ident p1)
{
    FUNC tmp = (FUNC) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FUNC2!\n");
        exit(1);
    }
    tmp->kind = is_FUNC2;
    tmp->u.func2_.ident_ = p1;
    return tmp;
}

/********************   FUNC3    ********************/

FUNC make_FUNC3(Ident p1, VALUE p2)
{
    FUNC tmp = (FUNC) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FUNC3!\n");
        exit(1);
    }
    tmp->kind = is_FUNC3;
    tmp->u.func3_.ident_ = p1;
    tmp->u.func3_.value_ = p2;
    return tmp;
}

/********************   VAILA1    ********************/

VAILA make_VAILA1(Integer p1)
{
    VAILA tmp = (VAILA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VAILA1!\n");
        exit(1);
    }
    tmp->kind = is_VAILA1;
    tmp->u.vaila1_.integer_ = p1;
    return tmp;
}

/********************   LABEL1    ********************/

LABEL make_LABEL1(Integer p1, Block p2)
{
    LABEL tmp = (LABEL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LABEL1!\n");
        exit(1);
    }
    tmp->kind = is_LABEL1;
    tmp->u.label1_.integer_ = p1;
    tmp->u.label1_.block_ = p2;
    return tmp;
}

/********************   ConjValuesVALUE    ********************/

ConjValues make_ConjValuesVALUE(VALUE p1)
{
    ConjValues tmp = (ConjValues) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjValuesVALUE!\n");
        exit(1);
    }
    tmp->kind = is_ConjValuesVALUE;
    tmp->u.conjvaluesvalue_.value_ = p1;
    return tmp;
}

/********************   ConjValues1    ********************/

ConjValues make_ConjValues1(VALUE p1, ConjValues p2)
{
    ConjValues tmp = (ConjValues) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjValues1!\n");
        exit(1);
    }
    tmp->kind = is_ConjValues1;
    tmp->u.conjvalues1_.value_ = p1;
    tmp->u.conjvalues1_.conjvalues_ = p2;
    return tmp;
}

/********************   ConjValues2D1    ********************/

ConjValues2D make_ConjValues2D1(ConjValues p1)
{
    ConjValues2D tmp = (ConjValues2D) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjValues2D1!\n");
        exit(1);
    }
    tmp->kind = is_ConjValues2D1;
    tmp->u.conjvalues2d1_.conjvalues_ = p1;
    return tmp;
}

/********************   ConjValues2D2    ********************/

ConjValues2D make_ConjValues2D2(ConjValues p1, ConjValues2D p2)
{
    ConjValues2D tmp = (ConjValues2D) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjValues2D2!\n");
        exit(1);
    }
    tmp->kind = is_ConjValues2D2;
    tmp->u.conjvalues2d2_.conjvalues_ = p1;
    tmp->u.conjvalues2d2_.conjvalues2d_ = p2;
    return tmp;
}

/********************   LConst    ********************/

PERMA make_LConst(Type p1, Ident p2, VALUE p3)
{
    PERMA tmp = (PERMA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LConst!\n");
        exit(1);
    }
    tmp->kind = is_LConst;
    tmp->u.lconst_.type_ = p1;
    tmp->u.lconst_.ident_ = p2;
    tmp->u.lconst_.value_ = p3;
    return tmp;
}

/********************   LPoint    ********************/

APONTA make_LPoint(Type p1, Ident p2, Ident p3)
{
    APONTA tmp = (APONTA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LPoint!\n");
        exit(1);
    }
    tmp->kind = is_LPoint;
    tmp->u.lpoint_.type_ = p1;
    tmp->u.lpoint_.ident_1 = p2;
    tmp->u.lpoint_.ident_2 = p3;
    return tmp;
}

/***************************   Cloning   ******************************/

S clone_S(S p)
{
  switch(p->kind)
  {
  case is_Sst:
    return make_Sst (clone_Block(p->u.sst_.block_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning S!\n");
    exit(1);
  }
}

Block clone_Block(Block p)
{
  switch(p->kind)
  {
  case is_LBlock:
    return make_LBlock (clone_CMDS(p->u.lblock_.cmds_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Block!\n");
    exit(1);
  }
}

CMDS clone_CMDS(CMDS p)
{
  switch(p->kind)
  {
  case is_CMDSCMD:
    return make_CMDSCMD (clone_CMD(p->u.cmdscmd_.cmd_));

  case is_CMDS1:
    return make_CMDS1
      ( clone_CMD(p->u.cmds1_.cmd_)
      , clone_CMDS(p->u.cmds1_.cmds_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning CMDS!\n");
    exit(1);
  }
}

CMD clone_CMD(CMD p)
{
  switch(p->kind)
  {
  case is_CMDATRIB:
    return make_CMDATRIB (clone_ATRIB(p->u.cmdatrib_.atrib_));

  case is_CMDEXP:
    return make_CMDEXP (clone_EXP(p->u.cmdexp_.exp_));

  case is_CMDUAI:
    return make_CMDUAI (clone_UAI(p->u.cmduai_.uai_));

  case is_CMDQUANTO:
    return make_CMDQUANTO (clone_QUANTO(p->u.cmdquanto_.quanto_));

  case is_CMDPA:
    return make_CMDPA (clone_PA(p->u.cmdpa_.pa_));

  case is_CMDZOIA:
    return make_CMDZOIA (clone_ZOIA(p->u.cmdzoia_.zoia_));

  case is_CMDVEMCA:
    return make_CMDVEMCA (clone_VEMCA(p->u.cmdvemca_.vemca_));

  case is_CMDPERMA:
    return make_CMDPERMA (clone_PERMA(p->u.cmdperma_.perma_));

  case is_CMDTREM:
    return make_CMDTREM (clone_TREM(p->u.cmdtrem_.trem_));

  case is_CMDFUNC:
    return make_CMDFUNC (clone_FUNC(p->u.cmdfunc_.func_));

  case is_CMDVAILA:
    return make_CMDVAILA (clone_VAILA(p->u.cmdvaila_.vaila_));

  case is_CMDLABEL:
    return make_CMDLABEL (clone_LABEL(p->u.cmdlabel_.label_));

  case is_CMDSTRUCT:
    return make_CMDSTRUCT (clone_STRUCT(p->u.cmdstruct_.struct_));

  case is_CMDAPONTA:
    return make_CMDAPONTA (clone_APONTA(p->u.cmdaponta_.aponta_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning CMD!\n");
    exit(1);
  }
}

ATRIB clone_ATRIB(ATRIB p)
{
  switch(p->kind)
  {
  case is_ATRIB1:
    return make_ATRIB1
      ( clone_Type(p->u.atrib1_.type_)
      , strdup(p->u.atrib1_.ident_)
      , clone_VALUE(p->u.atrib1_.value_)
      );

  case is_ATRIB2:
    return make_ATRIB2
      ( clone_Type(p->u.atrib2_.type_)
      , strdup(p->u.atrib2_.ident_)
      , clone_EXP(p->u.atrib2_.exp_)
      );

  case is_ATRIB3:
    return make_ATRIB3
      ( strdup(p->u.atrib3_.ident_)
      , clone_VALUE(p->u.atrib3_.value_)
      );

  case is_ATRIB4:
    return make_ATRIB4
      ( strdup(p->u.atrib4_.ident_)
      , clone_EXP(p->u.atrib4_.exp_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ATRIB!\n");
    exit(1);
  }
}

EXP clone_EXP(EXP p)
{
  switch(p->kind)
  {
  case is_EXP1:
    return make_EXP1
      ( clone_EXP(p->u.exp1_.exp_1)
      , clone_OPerA(p->u.exp1_.opera_)
      , clone_EXP(p->u.exp1_.exp_2)
      );

  case is_EXP2:
    return make_EXP2
      ( clone_EXP(p->u.exp2_.exp_1)
      , clone_OPerL(p->u.exp2_.operl_)
      , clone_EXP(p->u.exp2_.exp_2)
      );

  case is_EXP3:
    return make_EXP3 (clone_EXP(p->u.exp3_.exp_));

  case is_EXPVALUE:
    return make_EXPVALUE (clone_VALUE(p->u.expvalue_.value_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning EXP!\n");
    exit(1);
  }
}

UAI clone_UAI(UAI p)
{
  switch(p->kind)
  {
  case is_UAI1:
    return make_UAI1
      ( clone_OPL(p->u.uai1_.opl_)
      , clone_Block(p->u.uai1_.block_)
      );

  case is_UAI2:
    return make_UAI2
      ( clone_OPL(p->u.uai2_.opl_)
      , clone_Block(p->u.uai2_.block_1)
      , clone_Block(p->u.uai2_.block_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning UAI!\n");
    exit(1);
  }
}

OPerL clone_OPerL(OPerL p)
{
  switch(p->kind)
  {
  case is_OPerL1:
    return make_OPerL1 ();

  case is_OPerL2:
    return make_OPerL2 ();

  case is_OPerL3:
    return make_OPerL3 ();

  case is_OPerL4:
    return make_OPerL4 ();

  case is_OPerL5:
    return make_OPerL5 ();

  case is_OPerL6:
    return make_OPerL6 ();

  case is_OPerL7:
    return make_OPerL7 ();

  case is_OPerL8:
    return make_OPerL8 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning OPerL!\n");
    exit(1);
  }
}

OPerA clone_OPerA(OPerA p)
{
  switch(p->kind)
  {
  case is_OPerA1:
    return make_OPerA1 ();

  case is_OPerA2:
    return make_OPerA2 ();

  case is_OPerA3:
    return make_OPerA3 ();

  case is_OPerA4:
    return make_OPerA4 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning OPerA!\n");
    exit(1);
  }
}

OPL clone_OPL(OPL p)
{
  switch(p->kind)
  {
  case is_OPL1:
    return make_OPL1
      ( clone_EXP(p->u.opl1_.exp_1)
      , clone_OPerL(p->u.opl1_.operl_)
      , clone_EXP(p->u.opl1_.exp_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning OPL!\n");
    exit(1);
  }
}

ZOIA clone_ZOIA(ZOIA p)
{
  switch(p->kind)
  {
  case is_ZOIA1:
    return make_ZOIA1 (clone_VALUE(p->u.zoia1_.value_));

  case is_ZOIA2:
    return make_ZOIA2
      ( clone_VALUE(p->u.zoia2_.value_1)
      , clone_VALUE(p->u.zoia2_.value_2)
      );

  case is_ZOIA3:
    return make_ZOIA3
      ( clone_VALUE(p->u.zoia3_.value_1)
      , clone_VALUE(p->u.zoia3_.value_2)
      , clone_VALUE(p->u.zoia3_.value_3)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ZOIA!\n");
    exit(1);
  }
}

VEMCA clone_VEMCA(VEMCA p)
{
  switch(p->kind)
  {
  case is_VEMCA1:
    return make_VEMCA1
      ( clone_Type(p->u.vemca1_.type_)
      , strdup(p->u.vemca1_.ident_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning VEMCA!\n");
    exit(1);
  }
}

QUANTO clone_QUANTO(QUANTO p)
{
  switch(p->kind)
  {
  case is_QUANTO1:
    return make_QUANTO1
      ( clone_OPL(p->u.quanto1_.opl_)
      , clone_Block(p->u.quanto1_.block_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning QUANTO!\n");
    exit(1);
  }
}

PA clone_PA(PA p)
{
  switch(p->kind)
  {
  case is_PA1:
    return make_PA1
      ( clone_Type(p->u.pa1_.type_)
      , strdup(p->u.pa1_.ident_1)
      , clone_VALUE(p->u.pa1_.value_)
      , clone_OPL(p->u.pa1_.opl_)
      , strdup(p->u.pa1_.ident_2)
      , clone_EXP(p->u.pa1_.exp_)
      , clone_Block(p->u.pa1_.block_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning PA!\n");
    exit(1);
  }
}

VALUE clone_VALUE(VALUE p)
{
  switch(p->kind)
  {
  case is_VALUEIdent:
    return make_VALUEIdent (strdup(p->u.valueident_.ident_));

  case is_VALUE1:
    return make_VALUE1
      ( strdup(p->u.value1_.ident_)
      , clone_EXP(p->u.value1_.exp_)
      );

  case is_VALUE2:
    return make_VALUE2
      ( strdup(p->u.value2_.ident_)
      , clone_EXP(p->u.value2_.exp_1)
      , clone_EXP(p->u.value2_.exp_2)
      );

  case is_VALUEString:
    return make_VALUEString (strdup(p->u.valuestring_.string_));

  case is_VALUEInteger:
    return make_VALUEInteger (p->u.valueinteger_.integer_);

  case is_VALUEDouble:
    return make_VALUEDouble (p->u.valuedouble_.double_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning VALUE!\n");
    exit(1);
  }
}

Type clone_Type(Type p)
{
  switch(p->kind)
  {
  case is_Type_intero:
    return make_Type_intero ();

  case is_Type_floati:
    return make_Type_floati ();

  case is_Type_stringo:
    return make_Type_stringo ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Type!\n");
    exit(1);
  }
}

TREM clone_TREM(TREM p)
{
  switch(p->kind)
  {
  case is_TREM1:
    return make_TREM1
      ( clone_Type(p->u.trem1_.type_)
      , strdup(p->u.trem1_.ident_)
      , p->u.trem1_.integer_
      );

  case is_TREM2:
    return make_TREM2
      ( clone_Type(p->u.trem2_.type_)
      , strdup(p->u.trem2_.ident_)
      , p->u.trem2_.integer_
      , clone_ConjValues(p->u.trem2_.conjvalues_)
      );

  case is_TREM3:
    return make_TREM3
      ( clone_Type(p->u.trem3_.type_)
      , strdup(p->u.trem3_.ident_)
      , p->u.trem3_.integer_1
      , p->u.trem3_.integer_2
      );

  case is_TREM4:
    return make_TREM4
      ( clone_Type(p->u.trem4_.type_)
      , strdup(p->u.trem4_.ident_)
      , p->u.trem4_.integer_1
      , p->u.trem4_.integer_2
      , clone_ConjValues2D(p->u.trem4_.conjvalues2d_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning TREM!\n");
    exit(1);
  }
}

STRUCT clone_STRUCT(STRUCT p)
{
  switch(p->kind)
  {
  case is_STRUCT1:
    return make_STRUCT1
      ( p->u.struct1_.integer_
      , clone_HeteroElements(p->u.struct1_.heteroelements_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning STRUCT!\n");
    exit(1);
  }
}

HeteroElements clone_HeteroElements(HeteroElements p)
{
  switch(p->kind)
  {
  case is_HeteroElementsHeteroElement:
    return make_HeteroElementsHeteroElement (clone_HeteroElement(p->u.heteroelementsheteroelement_.heteroelement_));

  case is_HeteroElements1:
    return make_HeteroElements1
      ( clone_HeteroElement(p->u.heteroelements1_.heteroelement_)
      , clone_HeteroElements(p->u.heteroelements1_.heteroelements_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning HeteroElements!\n");
    exit(1);
  }
}

HeteroElement clone_HeteroElement(HeteroElement p)
{
  switch(p->kind)
  {
  case is_HeteroElementString:
    return make_HeteroElementString (strdup(p->u.heteroelementstring_.string_));

  case is_HeteroElementDouble:
    return make_HeteroElementDouble (p->u.heteroelementdouble_.double_);

  case is_HeteroElementInteger:
    return make_HeteroElementInteger (p->u.heteroelementinteger_.integer_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning HeteroElement!\n");
    exit(1);
  }
}

FUNC clone_FUNC(FUNC p)
{
  switch(p->kind)
  {
  case is_FUNC1:
    return make_FUNC1
      ( strdup(p->u.func1_.ident_)
      , clone_Block(p->u.func1_.block_)
      );

  case is_FUNC2:
    return make_FUNC2 (strdup(p->u.func2_.ident_));

  case is_FUNC3:
    return make_FUNC3
      ( strdup(p->u.func3_.ident_)
      , clone_VALUE(p->u.func3_.value_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning FUNC!\n");
    exit(1);
  }
}

VAILA clone_VAILA(VAILA p)
{
  switch(p->kind)
  {
  case is_VAILA1:
    return make_VAILA1 (p->u.vaila1_.integer_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning VAILA!\n");
    exit(1);
  }
}

LABEL clone_LABEL(LABEL p)
{
  switch(p->kind)
  {
  case is_LABEL1:
    return make_LABEL1
      ( p->u.label1_.integer_
      , clone_Block(p->u.label1_.block_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning LABEL!\n");
    exit(1);
  }
}

ConjValues clone_ConjValues(ConjValues p)
{
  switch(p->kind)
  {
  case is_ConjValuesVALUE:
    return make_ConjValuesVALUE (clone_VALUE(p->u.conjvaluesvalue_.value_));

  case is_ConjValues1:
    return make_ConjValues1
      ( clone_VALUE(p->u.conjvalues1_.value_)
      , clone_ConjValues(p->u.conjvalues1_.conjvalues_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ConjValues!\n");
    exit(1);
  }
}

ConjValues2D clone_ConjValues2D(ConjValues2D p)
{
  switch(p->kind)
  {
  case is_ConjValues2D1:
    return make_ConjValues2D1 (clone_ConjValues(p->u.conjvalues2d1_.conjvalues_));

  case is_ConjValues2D2:
    return make_ConjValues2D2
      ( clone_ConjValues(p->u.conjvalues2d2_.conjvalues_)
      , clone_ConjValues2D(p->u.conjvalues2d2_.conjvalues2d_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ConjValues2D!\n");
    exit(1);
  }
}

PERMA clone_PERMA(PERMA p)
{
  switch(p->kind)
  {
  case is_LConst:
    return make_LConst
      ( clone_Type(p->u.lconst_.type_)
      , strdup(p->u.lconst_.ident_)
      , clone_VALUE(p->u.lconst_.value_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning PERMA!\n");
    exit(1);
  }
}

APONTA clone_APONTA(APONTA p)
{
  switch(p->kind)
  {
  case is_LPoint:
    return make_LPoint
      ( clone_Type(p->u.lpoint_.type_)
      , strdup(p->u.lpoint_.ident_1)
      , strdup(p->u.lpoint_.ident_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning APONTA!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_S(S p)
{
  switch(p->kind)
  {
  case is_Sst:
    free_Block(p->u.sst_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing S!\n");
    exit(1);
  }
  free(p);
}

void free_Block(Block p)
{
  switch(p->kind)
  {
  case is_LBlock:
    free_CMDS(p->u.lblock_.cmds_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Block!\n");
    exit(1);
  }
  free(p);
}

void free_CMDS(CMDS p)
{
  switch(p->kind)
  {
  case is_CMDSCMD:
    free_CMD(p->u.cmdscmd_.cmd_);
    break;

  case is_CMDS1:
    free_CMD(p->u.cmds1_.cmd_);
    free_CMDS(p->u.cmds1_.cmds_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CMDS!\n");
    exit(1);
  }
  free(p);
}

void free_CMD(CMD p)
{
  switch(p->kind)
  {
  case is_CMDATRIB:
    free_ATRIB(p->u.cmdatrib_.atrib_);
    break;

  case is_CMDEXP:
    free_EXP(p->u.cmdexp_.exp_);
    break;

  case is_CMDUAI:
    free_UAI(p->u.cmduai_.uai_);
    break;

  case is_CMDQUANTO:
    free_QUANTO(p->u.cmdquanto_.quanto_);
    break;

  case is_CMDPA:
    free_PA(p->u.cmdpa_.pa_);
    break;

  case is_CMDZOIA:
    free_ZOIA(p->u.cmdzoia_.zoia_);
    break;

  case is_CMDVEMCA:
    free_VEMCA(p->u.cmdvemca_.vemca_);
    break;

  case is_CMDPERMA:
    free_PERMA(p->u.cmdperma_.perma_);
    break;

  case is_CMDTREM:
    free_TREM(p->u.cmdtrem_.trem_);
    break;

  case is_CMDFUNC:
    free_FUNC(p->u.cmdfunc_.func_);
    break;

  case is_CMDVAILA:
    free_VAILA(p->u.cmdvaila_.vaila_);
    break;

  case is_CMDLABEL:
    free_LABEL(p->u.cmdlabel_.label_);
    break;

  case is_CMDSTRUCT:
    free_STRUCT(p->u.cmdstruct_.struct_);
    break;

  case is_CMDAPONTA:
    free_APONTA(p->u.cmdaponta_.aponta_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CMD!\n");
    exit(1);
  }
  free(p);
}

void free_ATRIB(ATRIB p)
{
  switch(p->kind)
  {
  case is_ATRIB1:
    free_Type(p->u.atrib1_.type_);
    free(p->u.atrib1_.ident_);
    free_VALUE(p->u.atrib1_.value_);
    break;

  case is_ATRIB2:
    free_Type(p->u.atrib2_.type_);
    free(p->u.atrib2_.ident_);
    free_EXP(p->u.atrib2_.exp_);
    break;

  case is_ATRIB3:
    free(p->u.atrib3_.ident_);
    free_VALUE(p->u.atrib3_.value_);
    break;

  case is_ATRIB4:
    free(p->u.atrib4_.ident_);
    free_EXP(p->u.atrib4_.exp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ATRIB!\n");
    exit(1);
  }
  free(p);
}

void free_EXP(EXP p)
{
  switch(p->kind)
  {
  case is_EXP1:
    free_EXP(p->u.exp1_.exp_1);
    free_OPerA(p->u.exp1_.opera_);
    free_EXP(p->u.exp1_.exp_2);
    break;

  case is_EXP2:
    free_EXP(p->u.exp2_.exp_1);
    free_OPerL(p->u.exp2_.operl_);
    free_EXP(p->u.exp2_.exp_2);
    break;

  case is_EXP3:
    free_EXP(p->u.exp3_.exp_);
    break;

  case is_EXPVALUE:
    free_VALUE(p->u.expvalue_.value_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing EXP!\n");
    exit(1);
  }
  free(p);
}

void free_UAI(UAI p)
{
  switch(p->kind)
  {
  case is_UAI1:
    free_OPL(p->u.uai1_.opl_);
    free_Block(p->u.uai1_.block_);
    break;

  case is_UAI2:
    free_OPL(p->u.uai2_.opl_);
    free_Block(p->u.uai2_.block_1);
    free_Block(p->u.uai2_.block_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing UAI!\n");
    exit(1);
  }
  free(p);
}

void free_OPerL(OPerL p)
{
  switch(p->kind)
  {
  case is_OPerL1:
    break;

  case is_OPerL2:
    break;

  case is_OPerL3:
    break;

  case is_OPerL4:
    break;

  case is_OPerL5:
    break;

  case is_OPerL6:
    break;

  case is_OPerL7:
    break;

  case is_OPerL8:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OPerL!\n");
    exit(1);
  }
  free(p);
}

void free_OPerA(OPerA p)
{
  switch(p->kind)
  {
  case is_OPerA1:
    break;

  case is_OPerA2:
    break;

  case is_OPerA3:
    break;

  case is_OPerA4:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OPerA!\n");
    exit(1);
  }
  free(p);
}

void free_OPL(OPL p)
{
  switch(p->kind)
  {
  case is_OPL1:
    free_EXP(p->u.opl1_.exp_1);
    free_OPerL(p->u.opl1_.operl_);
    free_EXP(p->u.opl1_.exp_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OPL!\n");
    exit(1);
  }
  free(p);
}

void free_ZOIA(ZOIA p)
{
  switch(p->kind)
  {
  case is_ZOIA1:
    free_VALUE(p->u.zoia1_.value_);
    break;

  case is_ZOIA2:
    free_VALUE(p->u.zoia2_.value_1);
    free_VALUE(p->u.zoia2_.value_2);
    break;

  case is_ZOIA3:
    free_VALUE(p->u.zoia3_.value_1);
    free_VALUE(p->u.zoia3_.value_2);
    free_VALUE(p->u.zoia3_.value_3);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ZOIA!\n");
    exit(1);
  }
  free(p);
}

void free_VEMCA(VEMCA p)
{
  switch(p->kind)
  {
  case is_VEMCA1:
    free_Type(p->u.vemca1_.type_);
    free(p->u.vemca1_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing VEMCA!\n");
    exit(1);
  }
  free(p);
}

void free_QUANTO(QUANTO p)
{
  switch(p->kind)
  {
  case is_QUANTO1:
    free_OPL(p->u.quanto1_.opl_);
    free_Block(p->u.quanto1_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing QUANTO!\n");
    exit(1);
  }
  free(p);
}

void free_PA(PA p)
{
  switch(p->kind)
  {
  case is_PA1:
    free_Type(p->u.pa1_.type_);
    free(p->u.pa1_.ident_1);
    free_VALUE(p->u.pa1_.value_);
    free_OPL(p->u.pa1_.opl_);
    free(p->u.pa1_.ident_2);
    free_EXP(p->u.pa1_.exp_);
    free_Block(p->u.pa1_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing PA!\n");
    exit(1);
  }
  free(p);
}

void free_VALUE(VALUE p)
{
  switch(p->kind)
  {
  case is_VALUEIdent:
    free(p->u.valueident_.ident_);
    break;

  case is_VALUE1:
    free(p->u.value1_.ident_);
    free_EXP(p->u.value1_.exp_);
    break;

  case is_VALUE2:
    free(p->u.value2_.ident_);
    free_EXP(p->u.value2_.exp_1);
    free_EXP(p->u.value2_.exp_2);
    break;

  case is_VALUEString:
    free(p->u.valuestring_.string_);
    break;

  case is_VALUEInteger:
    break;

  case is_VALUEDouble:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing VALUE!\n");
    exit(1);
  }
  free(p);
}

void free_Type(Type p)
{
  switch(p->kind)
  {
  case is_Type_intero:
    break;

  case is_Type_floati:
    break;

  case is_Type_stringo:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Type!\n");
    exit(1);
  }
  free(p);
}

void free_TREM(TREM p)
{
  switch(p->kind)
  {
  case is_TREM1:
    free_Type(p->u.trem1_.type_);
    free(p->u.trem1_.ident_);
    break;

  case is_TREM2:
    free_Type(p->u.trem2_.type_);
    free(p->u.trem2_.ident_);
    free_ConjValues(p->u.trem2_.conjvalues_);
    break;

  case is_TREM3:
    free_Type(p->u.trem3_.type_);
    free(p->u.trem3_.ident_);
    break;

  case is_TREM4:
    free_Type(p->u.trem4_.type_);
    free(p->u.trem4_.ident_);
    free_ConjValues2D(p->u.trem4_.conjvalues2d_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TREM!\n");
    exit(1);
  }
  free(p);
}

void free_STRUCT(STRUCT p)
{
  switch(p->kind)
  {
  case is_STRUCT1:
    free_HeteroElements(p->u.struct1_.heteroelements_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing STRUCT!\n");
    exit(1);
  }
  free(p);
}

void free_HeteroElements(HeteroElements p)
{
  switch(p->kind)
  {
  case is_HeteroElementsHeteroElement:
    free_HeteroElement(p->u.heteroelementsheteroelement_.heteroelement_);
    break;

  case is_HeteroElements1:
    free_HeteroElement(p->u.heteroelements1_.heteroelement_);
    free_HeteroElements(p->u.heteroelements1_.heteroelements_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing HeteroElements!\n");
    exit(1);
  }
  free(p);
}

void free_HeteroElement(HeteroElement p)
{
  switch(p->kind)
  {
  case is_HeteroElementString:
    free(p->u.heteroelementstring_.string_);
    break;

  case is_HeteroElementDouble:
    break;

  case is_HeteroElementInteger:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing HeteroElement!\n");
    exit(1);
  }
  free(p);
}

void free_FUNC(FUNC p)
{
  switch(p->kind)
  {
  case is_FUNC1:
    free(p->u.func1_.ident_);
    free_Block(p->u.func1_.block_);
    break;

  case is_FUNC2:
    free(p->u.func2_.ident_);
    break;

  case is_FUNC3:
    free(p->u.func3_.ident_);
    free_VALUE(p->u.func3_.value_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FUNC!\n");
    exit(1);
  }
  free(p);
}

void free_VAILA(VAILA p)
{
  switch(p->kind)
  {
  case is_VAILA1:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing VAILA!\n");
    exit(1);
  }
  free(p);
}

void free_LABEL(LABEL p)
{
  switch(p->kind)
  {
  case is_LABEL1:
    free_Block(p->u.label1_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing LABEL!\n");
    exit(1);
  }
  free(p);
}

void free_ConjValues(ConjValues p)
{
  switch(p->kind)
  {
  case is_ConjValuesVALUE:
    free_VALUE(p->u.conjvaluesvalue_.value_);
    break;

  case is_ConjValues1:
    free_VALUE(p->u.conjvalues1_.value_);
    free_ConjValues(p->u.conjvalues1_.conjvalues_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ConjValues!\n");
    exit(1);
  }
  free(p);
}

void free_ConjValues2D(ConjValues2D p)
{
  switch(p->kind)
  {
  case is_ConjValues2D1:
    free_ConjValues(p->u.conjvalues2d1_.conjvalues_);
    break;

  case is_ConjValues2D2:
    free_ConjValues(p->u.conjvalues2d2_.conjvalues_);
    free_ConjValues2D(p->u.conjvalues2d2_.conjvalues2d_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ConjValues2D!\n");
    exit(1);
  }
  free(p);
}

void free_PERMA(PERMA p)
{
  switch(p->kind)
  {
  case is_LConst:
    free_Type(p->u.lconst_.type_);
    free(p->u.lconst_.ident_);
    free_VALUE(p->u.lconst_.value_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing PERMA!\n");
    exit(1);
  }
  free(p);
}

void free_APONTA(APONTA p)
{
  switch(p->kind)
  {
  case is_LPoint:
    free_Type(p->u.lpoint_.type_);
    free(p->u.lpoint_.ident_1);
    free(p->u.lpoint_.ident_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing APONTA!\n");
    exit(1);
  }
  free(p);
}

